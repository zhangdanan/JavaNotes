# 类加载机制

## 1.加载

主要是将class文件中的二进制字节流读入到jvm中

1. 通过类的权限定名获取该类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

## 2.连接

### 验证

确保加载进来的字节流符合JVM规范

1. 文件格式验证
2. 元数据验证，是否符合Java语言规范
3. 字节码验证，确保程序语义合法，符合逻辑
4. 符号引用验证，确保下一步的解析能正常执行

### 准备

为静态变量在方法区分配内存，并设置默认初始值

### 解析

虚拟机将常量池内的符号引用替换为直接引用

## 3.初始化

根据程序中的赋值语句主动为类变量赋值

### 什么时候需要初始化

1. 使用new该类实例化对象的时候
2. 读取或者设置类静态字段的时候（但被final修饰的字段，在编译器时就被放入常量池的静态字段除外static final）
3. 调用类静态方法的时候
4. 使用反射Class.forName（“xxxx”）对类进行反射调用的时候，该类需要初始化
5. 初始化一个类的时候，有父类，先初始化父类（1.接口除外，父接口在调用的时候才会被初始化，2.子类引用父类静态字段，只会引发父类初始化）
6. 被标明为启动类的类（即包含main方法的类要初始化）
7. 当使用JDK1.7的动态语言支持时，如果一个java.invoke,MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所应对的类没有进行过初始化，则需要先触发其初始化

### 初始化顺序

1. 父类的静态变量和静态块赋值（按照声明顺序）
2. 自身的静态变量和静态快赋值（按照声明顺序）
3. 父类成员变量和块赋值（按照声明顺序）
4. 父类构造器赋值，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用super（参数）指定调用父类的 有参构造器，不然就会报错
5. 自身成员变量和块赋值（按照声明顺序）
6. 自身构造器赋值

# 类加载器

## JVM提供的类加载器

- 启动类加载器（Bootstrap ClassLoader）：最顶层的类加载器，负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类
- 扩展类加载器（Extension ClassLoader）：负责加载JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库
- 应用程序类加载器（Application ClassLoader）：也叫做系统类加载器，可以通过getSystemClassLoader（）获取，负责加载用户路径（classpath）上的类库，如果没有自定义类加载器，一般这个就是默认的类加载器

## 双亲委派模型

如果一个类接受类加载器请求，他自己不会去加载这个请求，而是将这个类加载请求委派给父类加载器，这样一层一层传送，直到到达启动类加载器（Bootstrap ClassLoader）,只有当父类加载器无法加载这个请求时，子加载器才会尝试 自己去加载

## tomcat中的classLoader

- StandardClassLoader负责加载tomcat容器相关的类
- WebappClassLoader：每个web项目对应一个WebappClassLoader，这样做的目的是每个项目中都会有相同的类，而类的内容不一样，这个每个项目一个WebappClassLoader可以达到隔绝项目类冲突的问题



